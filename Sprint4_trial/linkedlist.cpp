#include "linkedlist.h"

template <class T>
LinkedList<T>::LinkedList()
{

}

template <class T>
LinkedList<T>::LinkedList(T data)
{

}

template <class T>
LinkedList<T>::LinkedList(const LinkedList<T>& rhs)
{

}

template <class T>
T LinkedList<T>::get(int index)
{

}

template <class T>
void LinkedList<T>::add(T data)
{

}

template <class T>
void LinkedList<T>::addToFront(T data)
{

}

template <class T>
int LinkedList<T>::size()
{

}

template <class T>
T LinkedList<T>::remove(int index)
{

}

template <class T>
LinkedList<T>::~LinkedList()
{

}

template <class T>
T& LinkedList<T>::operator[](int index)
{

}

template <class T>
LinkedList<T>& LinkedList<T>::operator=(LinkedList<T>& rhs)
{

}

/*
NodeList::Iterator::Iterator(Node* u) // constructor from Node*
{ v = u; }
Elem& NodeList::Iterator::operator*() // reference to the element
{ return v−>elem; } // compare positions
bool NodeList::Iterator::operator==(const Iterator& p) const
{ return v == p.v; }
bool NodeList::Iterator::operator!=(const Iterator& p) const
{ return v != p.v; } // move to next position
NodeList::Iterator& NodeList::Iterator::operator++()
{ v = v−>next; return *this; } // move to previous position
NodeList::Iterator& NodeList::Iterator::operator−−()
{ v = v−>prev; return *this; }
*/
